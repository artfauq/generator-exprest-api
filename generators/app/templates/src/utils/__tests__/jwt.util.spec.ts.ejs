import { hashSync } from 'bcryptjs';
import jwt from 'jsonwebtoken';
import Container from 'typedi';
import { config } from '../../config';
import { UserRoleEnum } from '../../types/enums';
import { generateSignedJWT, getJwtSecret } from '../jwt.util';
import { generateUUID } from '../string.util';

describe('JWT utils', () => {
  let hash: string;

  beforeAll(() => {
    hash = hashSync('fake-password');
  });

  describe('getJwtSecret()', () => {
    it('should return a JWT secret', () => {
      const jwtSecret = getJwtSecret(hash);

      expect(jwtSecret).toBe(`${config.secret}${hash}`);
    });
  });

  describe('generateSignedJWT()', () => {
    it('should return a signed JWT', () => {
      const userId = generateUUID();
      const payload = {
        name: 'John Doe',
        email: 'john@doe.com',
        role: UserRoleEnum.User,
      };

      const token = generateSignedJWT(userId, hash, payload);

      const decodedToken = jwt.decode(token, { json: true }) as { [key: string]: any };

      expect(decodedToken).toStrictEqual({
        email: payload.email,
        iat: expect.any(Number),
        iss: config.publicHost,
        jti: expect.any(String),
        name: payload.name,
        role: UserRoleEnum.User,
        sub: userId,
      });
    });
  });
});
