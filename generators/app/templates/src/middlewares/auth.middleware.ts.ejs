import { Request } from 'express';
import jwt, { SecretCallback<% if (auth) { %>, UnauthorizedError<% } %> } from 'express-jwt';<% if (i18n) { %>
import { i18n as I18n } from 'i18next';<% } %>
import { Container } from 'typedi';
import { User } from '../models';
import { config } from '../config';
import { DecodedJWT } from '../types';
import { getJwtSecret } from '../utils';

/**
 * Callback used to dynamically retrieve the secret used to sign a JWT.
 */
const secretCallback: SecretCallback = (
  req: Request,
  payload: DecodedJWT,
  done: (err: any, secret?: string) => void,
) => {<% if (i18n) { %>
  const i18n = Container.get<I18n>('i18n');
  const message = i18n.t('errors:invalidAuthentication');<% } else { %>
  const message = 'Invalid authentication.';<% } %>

  if (!payload || !payload.sub) {
    return done(new UnauthorizedError('invalid_token', { message }));
  }

  return User.findByPk(payload.sub, {
    attributes: {
      include: ['password'],
    },
  })
    .then(user => {
      if (!user) {
        return done(new UnauthorizedError('invalid_token', { message }));
      }

      const { password, ...currentUser } = user.get({ plain: true });

      req.user = currentUser;

      const secret = getJwtSecret(password);

      return done(null, secret);
    })
    .catch((err: any) => done(err, ''));
};

/**
 * Express request handler that verifies if a valid token exists through an `Authorization` header.
 *
 * Decoded payload will then be available in `req.user`.
 *
 * @example
 * router.get('/users', auth.required, usersController.getUsers);
 */
export const auth = {
  required: jwt({
    algorithms: ['HS256'],
    secret: secretCallback,
    requestProperty: 'auth',
  }),
  optional: jwt({
    algorithms: ['HS256'],
    secret: secretCallback,
    credentialsRequired: false,
    requestProperty: 'auth',
  }),
};
