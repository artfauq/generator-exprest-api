import { compare } from 'bcryptjs';
import { BadRequest } from 'http-errors';<% if (i18n) { %>
import { i18n as I18n } from 'i18next';<% } %>
import {
  Attributes,
  CreationOptional,
  InferAttributes,
  InferCreationAttributes,
  Op,
  Transaction,
} from 'sequelize';
import {
  AllowNull,
  BeforeCreate,
  BeforeUpdate,
  Column,
  Comment,
  CreatedAt,
  DataType,
  Default,
  DefaultScope,
  Model,
  PrimaryKey,
  Table,
  Unique,
} from 'sequelize-typescript';<% if (i18n) { %>
import { Container } from 'typedi';<% } %>
import { UserRoleEnum } from '../types/enums';
import { generateHash<% if (auth) { %>, generateSignedJWT<% } %> } from '../utils';

export type UserAttributes = Omit<Attributes<User>, 'password'>;

@DefaultScope(() => ({
  attributes: {
    exclude: ['password'],
  },
}))
@Table({
  charset: 'utf8',
  collate: 'utf8_general_ci',
  tableName: 'user',
})
export class User extends Model<
  InferAttributes<User>,
  InferCreationAttributes<User, { omit: 'fullName' }>
> {
  // ─── Model attributes ────────────────────────────────────────────────

  @PrimaryKey
  @AllowNull(false)
  @Comment('ID of the user')
  @Default(DataType.UUIDV4)
  @Column(DataType.UUID)
  id!: CreationOptional<string>;

  @AllowNull(false)
  @Comment('First name of the user')
  @Column(DataType.STRING(64))
  firstName!: string;

  @AllowNull(false)
  @Comment('Last name of the user')
  @Column(DataType.STRING(64))
  lastName!: string;

  @Column(DataType.VIRTUAL)
  get fullName(): string {
    return `${this.getDataValue('firstName')} ${this.getDataValue('lastName')}`;
  }

  @Unique
  @AllowNull(false)
  @Comment('Email of the user')
  @Column(DataType.STRING(128))
  email!: string;

  @AllowNull(false)
  @Comment('Password of the user')
  @Column(DataType.STRING(64))
  password!: string;

  @AllowNull(false)
  @Comment('User role')
  @Default(UserRoleEnum.User)
  @Column(DataType.ENUM(...Object.values(UserRoleEnum)))
  role!: CreationOptional<UserRoleEnum>;

  @CreatedAt
  @AllowNull(false)
  @Comment("Date and time of the user's profile creation")
  @Column(DataType.DATE)
  createdAt!: CreationOptional<Date>;

  // ─── Model hooks ─────────────────────────────────────────────────────

  @BeforeCreate
  @BeforeUpdate
  static async checkEmailUniqueness(
    user: User,
    options?: { transaction?: Transaction },
  ): Promise<void> {<% if (i18n) { %>
    const i18n = Container.get<I18n>('i18n');
<% } %>
    if (user.changed('email')) {
      const email = user.getDataValue('email');
      const emailCount = await User.count({
        where: {
          id: { [Op.ne]: user.id },
          email,
        },
        transaction: options?.transaction,
      });

      if (emailCount > 0) {
        throw new BadRequest(<% if (i18n) { %>i18n.t('errors:emailAlreadyUsed')<% } else { %>'An account with this email address already exists.'<% } %>);
      }
    }
  }

  @BeforeCreate
  @BeforeUpdate
  static async hashPassword(user: User): Promise<void> {
    if (user.changed('password')) {
      const hash = await generateHash(user.password);

      user.password = hash;
    }
  }

  // ─── Model hooks ─────────────────────────────────────────────────────

  /**
   * Returns `true` if `password` matches the user's password, `false` otherwise.
   */
  async comparePassword(password: string): Promise<boolean> {
    return compare(password, this.password);
  }<% if (auth) { %>

  /**
   * Returns a new JWT for this user.
   */
  async generateJWT(): Promise<string> {
    const user = await User.findByPk(this.id, {
      attributes: {
        include: ['password'],
      },
    });

    if (!user) {
      throw new Error(`User not found with id '${this.id}'`);
    }

    return generateSignedJWT(user.id, user.password, {
      name: user.fullName,
      email: user.email,
      role: user.role,
    });
  }<% } %>
}
