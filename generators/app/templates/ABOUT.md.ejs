# About <!-- omit in toc -->

- [Environment variables](#environment-variables)
- [Project structure](#project-structure)<% if (docker) { %>
- [Docker](#docker)
  - [Development mode](#development-mode)<% if (mocha) { %>
  - [Test mode](#test-mode)<% } %>
  - [Production mode](#production-mode)<% } %><% if (sequelize || redis) { %>
- [Services](#services)<% if (sequelize) { %>
  - [Sequelize](#sequelize)
    - [Models](#models)
    - [Migrations](#migrations)
    - [Seed](#seed)<% } %><% if (redis) { %>
  - [Redis](#redis)<% } %><% } %>
- [Features](#features)
  - [Dependency injection](#dependency-injection)
  - [DTO and types](#dto-and-types)
  - [Routing](#routing)
  - [Error handling](#error-handling)<% if (celebrate) { %>
  - [Object validation](#object-validation)<% } %><% if (mocha) { %>
  - [Testing](#testing)<% } %><% if (i18n) { %>
  - [i18n](#i18n)<% } %><% if (cron) { %>
  - [Job scheduler](#job-scheduler)<% } %><% if (monitoring) { %>
  - [API status monitoring](#api-status-monitoring)<% } %><% if (sentry) { %>
  - [Sentry](#sentry)<% } %><% if (socketIo) { %>
  - [Socket IO](#socket-io)<% } %><% if (nodemailer) { %>
  - [Nodemailer](#nodemailer)<% } %><% if (openapi) { %>
  - [API documentation](#api-documentation)<% } %><% if (admin) { %>
  - [Admin panel](#admin-panel)<% } %>
- [Style Guide](#style-guide)
  - [Filenames](#filenames)
  - [Formatting](#formatting)
  - [Linting](#linting)<% if (hook) { %>
  - [Pre-commit hook](#pre-commit-hook)<% } %><% if (openapi) { %>
- [Version update](#version-update)<% } %><% if (winston) { %>
- [Logs](#logs)<% } %>

## Environment variables

The `.env.example` should list all the environment variables that the application needs to run.

A `.env` file with the environment variable key/value pairs should reside at the root of the project. The `dotenv` package imported in `/src/config/index.ts` will make those variables available to the app.

## Project structure

The project is structured as follows:
<% if (sequelize) { %>
- `/db`: database related files
  - `/migrations`: database migrations
  - `/seeders`: database seeders<% } %><% if (docker) { %>
- `/docker`: Docker configuration files<% } %>
- `/public`: public assets (<% if (openapi) { %>API documentation, <% } %>images, etc)
- `/src`: application source files<% if (admin) { %>
  - `/admin`: admin related files
    - `/components`: custom React components used in the admin panel
    - `/locale`: admin translation files
    - `/resources`: admin resources definitions<% } %>
  - `/config`: configuration files
  - `/dto`: Data Transfer Object definitions<% if (cron) { %>
  - `/jobs`: cron jobs definitions<% } %>
  - `/loaders`: application loaders definitions<% if (i18n) { %>
  - `/locale`: i18n resources<% } %>
  - `/middlewares`: middlewares definitions<% if (sequelize) { %>
  - `/models`: database models definitions<% } %>
  - `/routes`: routes definitions
  - `/services`: business logic (database interaction, API interactions, etc)
  - `/types`: custom types definitions
    - `/enums`: enum definitions
  - `/utils`: utilities and helpers<% if (mocha) { %>
- `/test`: testing files<% } %>
<% if (winston || mocha) { %>
When running the app or performing some commands, additional folders (ignored by Git) will be created such as:
<% if (winston) { %>
- `/logs`: application logs (errors, info, etc...) generated by `winston` when the application is running<% } %><% if (mocha) { %>
- `/.nyc_output`: test coverage output generated by `nyc` after running `yarn test`<% } %>
<% } %><% if (docker) { %>
## Docker

Docker Compose is the recommended method to run this project. This way, the project can easily run either in a development<% if (mocha) { %>, test<% } %> or production environment.

These configurations are defined respectively in `docker-compose.dev.yml`<% if (mocha) { %>, `docker-compose.test.yml`<% } %> and `docker-compose.prod.yml`. They all inherit from the base configuration defined in `docker-compose.yml`.

The `start.sh` script located in the `/docker` folder allows to start docker-compose in one of these modes as follows:

```sh
./docker/start.sh <dev<% if (mocha) { %>|test<% } %>|prod>
```

Running this command will start various containers such as:

- `<%= shortname %>`: a Node.JS web server<% if (sequelize) { %>
- `<%= shortname %>-db`: a <%= dialect.name %> database server
- `<%= shortname %>-migrate`: a container that starts to run the database migrations and exits immediately after (it runs right after the `<%= shortname %>` image was built)<% } %><% if (redis) { %>
- `<%= shortname %>-redis`: a Redis server<% } %>

### Development mode

To start all containers in `development` mode, run:

```sh
./docker/start.sh dev
```

This will:

- Target the `development` stage of the multi-stage [Dockerfile](/docker/node/Dockerfile)
- Run the `yarn dev` command in the `<%= shortname %>` container<% if (sequelize) { %>
- Run database migrations from the `<%= shortname %>-migrate` container<% } %>
- Allow the web server to restart automatically on source files changes detected<% if (mocha) { %>

### Test mode

To start all containers in `test` mode, run:

```sh
./docker/start.sh test
```

This will:

- Target the `development` stage of the multi-stage [Dockerfile](/docker/node/Dockerfile)
- Run the `yarn test` command in the `<%= shortname %>-test` container<% } %>

### Production mode

To start all containers in `production` mode, run:

```sh
./docker/start.sh prod
```

This will:

- Target the `final` stage of the multi-stage [Dockerfile](/docker/node/Dockerfile)
- Run the `node ./dist/index.js` command in the `<%= shortname %>` container

In production environment, some other containers are mounted:
<% if (sequelize && dialect.value === 'mysql') { %>
- `<%= shortname %>-db-backup`: a container that runs a database backup script as a cron job and outputs the resulting SQL file in a `/backup` folder<% } %>
- `nginx-proxy`, `nginx-proxy-gen` and `nginx-proxy-le`: these containers enable a reverse Nginx proxy with automatic Let's Encrypt SSL certificate renewal

In addition, all containers are configured to restart automatically unless stopped manually.
<% } %><% if (sequelize || redis) { %>
## Services
<% if (sequelize) { %>
### Sequelize

The project uses [sequelize](https://github.com/sequelize/sequelize) as an ORM to connect to a <%= dialect.name %> database and [sequelize-cli](https://github.com/sequelize/cli) to perform database related commands.

- Database connection options are defined in `/src/config/index.ts` through the `DB_` environment variables
- Sequelize instance is initialized and exported from `/src/loaders/sequelize.ts`.
- Sequelize CLI options are defined in `.sequelizerc` and `/db/config.js`

#### Models

This project uses [sequelize-typescript](https://github.com/RobinBuschmann/sequelize-typescript) which brings in decorators and some other features for Sequelize.

Sequelize models should be defined in `/src/models`. Each model should be declared in a separate file and imported in `/src/models/index.ts`.

For example, to declare two new models `User` and `UserAddress`:

- Create a new file `user.ts` in `/src/models`:

```typescript
import bcrypt from 'bcryptjs';
import { BadRequest } from 'http-errors';<% if (i18n) { %>
import { i18n as I18n } from 'i18next';<% } %>
import {
  AllowNull,
  BeforeValidate,
  Column,
  Comment,
  CreatedAt,
  DataType,
  Default,
  Model,
  PrimaryKey,
  Table,
  Unique,
} from 'sequelize-typescript';<% if (i18n) { %>
import Container from 'typedi';<% } %><% if (jwt) { %>
import { generateSignedJWT } from '../utils/jwt';<% } %>

@Table({
  tableName: 'user',
})
export default class UserModel extends Model<UserModel> {
  //
  // ─── MODEL ATTRIBUTES ───────────────────────────────────────────────────────────
  //

  @PrimaryKey
  @AllowNull(false)
  @Comment('ID of the user')
  @Default(DataType.UUIDV4)
  @Column(DataType.UUID)
  id!: string;

  @AllowNull(false)
  @Comment('First name of the user')
  @Column(DataType.STRING(64))
  firstName!: string;

  @AllowNull(false)
  @Comment('Last name of the user')
  @Column(DataType.STRING(64))
  lastName!: string;

  @Unique
  @AllowNull(false)
  @Comment('Email of the user')
  @Column(DataType.STRING(128))
  email!: string;

  @AllowNull(false)
  @Comment('Password of the user')
  @Column(DataType.STRING(64))
  password!: string;

  @CreatedAt
  @AllowNull(false)
  @Comment("Date and time of the user's profile creation date")
  @Column(DataType.DATE)
  createdAt!: string;

  //
  // ─── VIRTUAL ATTRIBUTES ─────────────────────────────────────────────────────────
  //

  @Column(DataType.VIRTUAL)
  get fullName(): string {
    return `${this.getDataValue('firstName')} ${this.getDataValue('lastName')}`;
  }

  //
  // ─── MODEL ASSOCIATIONS ─────────────────────────────────────────────────────────
  //

  //
  // ─── MODEL HOOKS ────────────────────────────────────────────────────────────────
  //

  @BeforeValidate
  static async validateUserFields(user: UserModel): Promise<void> {<% if (i18n) { %>
    const i18n = Container.get<I18n>('i18n');
<% } %>
    // If `email` property changed
    if (user.changed('email')) {
      const email = user.getDataValue('email');
      const emailCount = await UserModel.count({ where: { email } });

      if (emailCount > 0) {
        throw new BadRequest(<% if (i18n) { %>i18n.t('errors:emailAlreadyUsed', { email })<% } else { %>`The email address ${email} is already in use.`<% } %>);
      }
    }

    // If `password` property changed
    if (user.changed('password')) {
      const password = user.getDataValue('password');
      const hash = await UserModel.generateHash(password);

      user.setDataValue('password', hash);
    }

    await user.save({ validate: false });
  }

  //
  // ─── CUSTOM METHODS ─────────────────────────────────────────────────────────────
  //

  /**
   * Returns a hashed version of the given `password`.
   */
  static async generateHash(password: string): Promise<string> {
    return bcrypt.hash(password, 10);
  }

  /**
   * Returns `true` if `password` matches the user's password, `false` otherwise.
   */
  async comparePassword(password: string): Promise<boolean> {
    const hash = this.getDataValue('password');

    return bcrypt.compare(password, hash);
  }<% if (jwt) { %>

  /**
   * Returns a new JWT for this user.
   */
  generateJWT(): string {
    return generateSignedJWT(this.id, this.password, {
      name: this.fullName,
      email: this.email,
    });
  }<% } %>
}
```

- Create a new file `user-address.ts` in `/src/models`:

```typescript
import {
  AllowNull,
  BelongsTo,
  Column,
  Comment,
  DataType,
  ForeignKey,
  Model,
  PrimaryKey,
  Table,
} from 'sequelize-typescript';
import { UserModel } from '.';

@Table({
  tableName: 'user_address',
  charset: 'utf8',
  collate: 'utf8_general_ci',
})
export default class UserAddressModel extends Model<UserAddressModel> {
  //
  // ─── MODEL ATTRIBUTES ───────────────────────────────────────────────────────────
  //

  @PrimaryKey
  @ForeignKey(() => UserModel)
  @AllowNull(false)
  @Comment('ID of the user')
  @Column(DataType.UUID)
  userId!: string;

  @AllowNull(false)
  @Comment('Street address of the user')
  @Column(DataType.STRING(60))
  streetAddress!: string;

  @AllowNull(false)
  @Comment('Zip code of the user')
  @Column(DataType.STRING(5))
  zip!: string;

  @AllowNull(false)
  @Comment('City of the user')
  @Column(DataType.STRING(60))
  city!: string;

  @AllowNull(false)
  @Comment('Country code of the user')
  @Column(DataType.STRING(2))
  countryCode!: string;

  //
  // ─── VIRTUAL ATTRIBUTES ─────────────────────────────────────────────────────────
  //

  //
  // ─── MODEL ASSOCIATIONS ─────────────────────────────────────────────────────────
  //

  @BelongsTo(() => UserModel, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE',
  })
  user!: UserModel;

  //
  // ─── MODEL HOOKS ────────────────────────────────────────────────────────────────
  //
}
```

- Export the models from `/src/models/index.ts`

```typescript
// Export models from here

export { default as UserModel } from './User';
export { default as UserAddressModel } from './UserAddress';
```

#### Migrations

Migrations are defined in `/db/migrations`.

##### Run migrations <!-- omit in toc -->

To update the database with latest model changes, run migrations with [Sequelize CLI](https://github.com/sequelize/cli) with the following command:

```sh
yarn migrations:migrate
```

To undo the most recent migration, run the following command:

```sh
yarn migrations:undo
```

##### Create a new migration <!-- omit in toc -->

To create an empty migration file, run:

```sh
yarn migrations:create <migration_name>
```

For more information about migrations and seeders, please refer to [the docs](https://sequelize.org/master/manual/migrations.html).

#### Seed

Seeders are defined in `/db/seeders`.

To fill the database with initial data, run seeders with the following command:

```sh
yarn seed
```

For more information about migrations and seeders, please refer to [the docs](https://sequelize.org/master/manual/migrations.html#running-seeds).
<% } %><% if (redis) { %>
### Redis

The redis client is configured in `/src/loaders/redis.ts` and injected in the application as the `redis` service.

If you're not familiar with its usage, please refer to [the docs](https://github.com/NodeRedis/node-redis).
<% } %><% } %>
## Features

### Dependency injection

This project uses [typedi](https://github.com/typestack/typedi) to perform dependency injection.

Services are injected in the application at launch from `/src/index.ts` with the command:

```typescript
Container.set('myService', myService);
```

Injected services become available in the application in two ways:

- From the constructor of a class:

```typescript
import { Inject, Service } from 'typedi';<% if (winston) { %>
import { Logger } from 'winston';<% var loggerType = 'Logger'; %><% } else { %><% var loggerType = 'Console'; %><% } %>

@Service()
export default class UserService {
  constructor(@Inject('logger') private logger: <%= loggerType %>) {}

  async createUser(userDetails: Object): Promise<void> {
    this.logger.info('Message logged by the logger instance');
  }
}
```

- Using `Container.get`:

```typescript
import { Container, Service } from 'typedi';<% if (winston) { %>
import { Logger } from 'winston';<% var loggerType = 'Logger'; %><% } else { %><% var loggerType = 'Console'; %><% } %>

@Service()
export default class UserService {
  async createUser(userDetails: Object): Promise<void> {
    const logger = Container.get<<%= loggerType %>>('logger');

    this.logger.info('Message logged by the logger instance');
  }
}
```

### DTO and types

Data Transfer Object methods ensure the data you send back to your API's clients are formatted as needed.

For example, to create a new `User` type and a new `userDTO` method, follow these steps:

- Create a new file `/src/types/user.ts` to declare the `User` type:

```typescript
export type User = {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
};
```

- Export this new type from `/src/types/index.ts`:

```typescript
// Export types from here
<% if (auth) { %>
export * from './auth';<% } %><% if (jwt) { %>
export * from './jwt';<% } %>
export * from './user';

export { default } from './index.d';
```

- Create a new DTO file `/src/dto/user.ts`:

```typescript
import { UserModel } from '../models';
import { User } from '../types';

export const userDTO = (userDetails: UserModel): User => {
  const user: User = {
    id: userDetails.id,
    firstName: userDetails.firstName,
    lastName: userDetails.lastName,
    email: userDetails.email,
    phone: userDetails.phone,
  };

  return user;
};
```

- Export the DTO method from `/src/dto/index.ts`:

```typescript
// Export DTO methods from here

export * from './user';
```

### Routing

- All routes should be defined in `/src/routes`
- For each main route endpoint, a new file with the route endpoint as filename should be added to the `/routes` folder
- All the business logic (retrieving, creating or updating data, etc) should be defined in the `/src/services` folder

For example, to define a new `/users` endpoint and two routes `POST /users` and `GET /users/:id`, follow these steps:

- Create a new service `/src/services/user.ts` to handle the business logic of creating and retrieving a user:

```typescript<% if (i18n) { %>
import { i18n as I18n } from 'i18next';
import { Inject, Service } from 'typedi';<% } %>
import { BadRequest, NotFound } from 'http-errors';
import { userDTO } from '../dto';
import { UserModel } from '../models';
import { CreateUserDTO, User } from '../types';

@Service()
export default class UserService {<% if (i18n) { %>
  constructor(@Inject('i18n') private i18n: I18n) {}
<% } %>
  /**
   * Returns the details of a user or throws a `NotFound` error if not found.
   */
  async getUserById(userId: string): Promise<User> {
    const user = await UserModel.findByPk(userId);

    if (!user) {
      throw new NotFound(<% if (i18n) { %>this.i18n.t('errors:userNotFound')<% } else { %>'User not found.'<% } %>);
    }

    return userDTO(user);
  }

  /**
   * Creates a new user or throws a `BadRequest` error if a user with the same email address already exists.
   */
  async createUser(userDetails: CreateUserDTO): Promise<User> {
    const existingUser = await UserModel.findOne({ where: { email: userDetails.email } });

    if (existingUser) {
      throw new BadRequest(<% if (i18n) { %>this.i18n.t('errors:duplicateEmail')<% } else { %>'This email address is already in use.'<% } %>);
    }

    const user = await UserModel.create(userDetails);

    return userDTO(user);
  }
}
```

- Export the new service from `/src/services/index.ts`:

```typescript
// Export services from here
<% if (auth) { %>
export { default as AuthService } from './auth';<% } %><% if (nodemailer) { %>
export { default as EmailService } from './email';<% } %>
export { default as UserService } from './user';
```

- Create a new route file `/src/routes/users.ts` with the request handlers:

```typescript
import Router from 'express-promise-router';
import { Container } from 'typedi';<% if (celebrate) { %>
import { validation } from '../middlewares';<% } %>
import { UserService } from '../services';
import { CreateUserDTO, User } from '../types';

const router = Router();

/**
 * GET /users/:id
 *
 * Retrieve a user's details
 */
router.get<{ id: string }, { user: User }>(
  '/:id',<% if (celebrate) { %>
  validation.celebrate({
    params: {
      id: validation.schemas.uuid.required(),
    },
  }),<% } %>
  async (req, res) => {
    const { id } = req.params;

    const user = await Container.get(UserService).getUserById(id);

    res.status(201).json({ user });
  },
);

/**
 * POST /users
 *
 * Register new user
 */
router.post<{}, { user: User }, CreateUserDTO>(
  '/',<% if (celebrate) { %>
  validation.celebrate({
    body: validation.Joi.object({
      firstName: validation.schemas.firstName.required(),
      lastName: validation.schemas.lastName.required(),
      email: validation.schemas.email.required(),
      password: validation.schemas.password.required(),
      phone: validation.schemas.phoneNumber.required(),
    }).required(),
  }),<% } %>
  async (req, res) => {
    const userDetails = req.body;

    const user = await Container.get(UserService).createUser(userDetails);

    res.status(201).json({ user });
  },
);

export default router;
```

- Finally, import the router in `/src/routes/index.ts` and declare a new `/users` route:

```typescript
import Router from 'express-promise-router';
import { NotFound } from 'http-errors';
import morgan from 'morgan';
import logger from '../config/logger';
import usersRouter from './users';

const router = Router();

/**
 * Router configuration
 */
router.use(
  morgan('dev', {
    stream: {
      write: message => logger.info(message.trim()),
    },
  }),
);

/**
 * API routes
 */
router.use('/users', usersRouter);

/**
 * 404 error handling
 */
router.use((req, res, next) => {
  const { baseUrl, url, method } = req;

  next(new NotFound(<% if (i18n) { %>req.i18n.t('errors:routeNotFound', { method, baseUrl, url })<% } else { %>`The route '${method} ${baseUrl}${url}' doesn't exist.`<% } %>));
});

export default router;
```

### Error handling

HTTP error responses are handled by the `httpErrorHandler` middleware defined in `/src/server.ts`.

When an error is thrown inside of a route controller with `next()` or inside a service with `throw`, the middleware will try to parse the error into a standard HTTP error and send back the error to the client.

To throw custom HTTP errors, use the `http-errors` library.

For example, to throw a `NotFound` error:

```typescript
import { NotFound } from 'http-errors';<% if (i18n) { %>
import { i18n as I18n } from 'i18next';
import { Inject, Service } from 'typedi';<% } %>
import { UserModel } from '../models';

@Service()
export default class UserService {<% if (i18n) { %>
  constructor(@Inject('i18n') private i18n: I18n) {}
<% } %>
  async function getUserById(userId) {
    const user = await UserModel.findByPk(userId);

    if (!user) {
      throw new NotFound(<% if (i18n) { %>this.i18n.t('errors:userNotFound')<% } else { %>'User not found.'<% } %>);
    }

    return user;
  }
}
```

In addition, the routes defined in `/src/routes` should use the `Router` from the [express-promise-router](https://github.com/express-promise-router/express-promise-router) package instead of the `Router` from `express`. It provides a convenient way to write async request controllers.
<% if (celebrate) { %>
### Object validation

To validate HTTP request parameters and body, use [celebrate](https://www.npmjs.com/package/celebrate).

Custom validation schemas should be defined in `/src/middlewares/validation.ts`.

For example, to add validation to the `id` parameter of the `GET /users/:id` route:

- Define a new validation schema in `/src/middlewares/validation.ts`:

```typescript
import { celebrate } from 'celebrate';
import Joi from '@hapi/joi';

const id = Joi.number().integer().positive();

//
// ─── GENERIC VALIDATION SCHEMAS ─────────────────────────────────────────────────
//

const schemas = {
  id,
};

export { celebrate, customJoi as Joi, schemas };
```

- Add the validation schema to the route definition in `/src/routes/users.ts`:

```typescript
import Router from 'express-promise-router';
import { Container } from 'typedi';
import { validation } from '../middlewares';
import { UserService } from '../services';

const router = Router();

/**
 * GET /users/:id
 */
router.get(
  '/:id',
  celebrate({
    params: {
      id: validation.schemas.id
        .required()
        .error(() => 'User ID is required and must be a positive integer.'),
    },
  }),
  async (req, res) => {
    const { id } = req.params;

    const user = await Container.get(UserService).getUserById(id);

    res.status(200).json(user);
  },
);
```

Validation errors are handled by the `celebrateErrorHandler` middleware defined in `/src/server.ts`:
<% } %><% if (mocha) { %>
### Testing

Tests are run with [Mocha](https://mochajs.org/), [Chai](https://www.chaijs.com/) and [SuperTest](https://github.com/visionmedia/supertest). Test coverage is performed by [nyc](https://github.com/istanbuljs/nyc).

Mocha and nyc are configured respectively in [`.mocharc.json`](./.mocharc.json) and [`.nycrc.json`](./.nycrc.json).

#### Running tests <!-- omit in toc -->

Run tests with the following command:

```sh
yarn test
```

This will:

- Set the `NODE_ENV` variable to `test`<% if (sequelize) { %>
- Create/reset a test database with migrations and seeders<% } %>
- Execute the content of `/test/setup.ts`
- Run all tests (files ending with `test.ts`) defined in the `/test` folder

#### Tests structure <!-- omit in toc -->

The `/test` folder is structured as follows:

- `/helpers`: test helpers
  - `/stubs`: test stub definitions
- `/integration`: integration test files
  - `/api`: API test files
- `/unit`: unit test files

All API tests should be defined in `/test/integration/api` with one directory per main route and inside each directory one file per endpoint.

For example: if a `POST /users` route is defined, the associated test file would be `/test/integration/api/users/post.users.test.ts`.
<% } %><% if (i18n) { %>
### i18n

i18n is configured with [i18next](https://www.i18next.com/) in `/src/loaders/i18n.ts` and injected in the application as the `i18n` service.

Translations are located in `/src/locale`.

All incoming requests are parsed by `i18next-http-middleware` to retrieve the request's accepted language. The i18n instance and accepted language are then available respectively in `req.i18n` and `req.language`.

To add a new language, for example Spanish:

- In `/src/locale`, create a new file `es.json`
- In `/src/locale/index.ts`, export this new language by adding:

```typescript
// Export translations files from here

export { default as es } from './es.json';
```

- In `/src/loaders/i18n.ts`, add `'es'` to the `supportedLngs` property
<% } %><% if (cron) { %>
### Job scheduler

Cron jobs are handled by the [node-schedule](https://github.com/node-schedule/node-schedule) library.

To create a new job, for example a logs cleaning job:

- In `/src/jobs`, create a new file `clean-logs.ts` with the following content:

```typescript
import moment from 'moment';
import { JobCallback } from 'node-schedule';
import { Container } from 'typedi';
import { Op } from 'sequelize';
import { Logger } from 'winston';
import { LogModel } from '../models';

export default (): JobCallback => () => {
  const logger = Container.get<Logger>('logger');

  logger.info('Running logs cleaning job');

  const createdAt = moment().subtract(50, 'days').format('YYYY-MM-DD');

  LogModel.destroy({
    where: {
      createdAt: {
        [Op.lte]: createdAt,
      },
    },
  })
    .then(deletedRowsCount =>
      logger.info(`Completed logs cleaning job with ${deletedRowsCount} rows deleted`),
    )
    .catch(err => {
      logger.error(`Logs cleaning job failed: ${err}`);
    });
};
```

- In `/src/jobs/index.ts`, export this new job by adding:

```typescript
// Export individual jobs from here

export { default as cleanJobs } from './clean-logs';
```

- In `/src/loaders/job-scheduler.ts`, configure the execution date of this new job:

```typescript
import scheduler from 'node-schedule';
import * as jobs from '../jobs';

/**
 * Job scheduler initializer
 */
export default (): void => {
  // Run logs cleaning job every day at 3 AM
  scheduler.scheduleJob('0 0 3 * * *', jobs.cleanLogs());
};
```
<% } %><% if (monitoring) { %>
### API status monitoring

This project uses [express-status-monitor](https://github.com/RafalWilinski/express-status-monitor) to easily monitor the status of the web server.

Monitoring is available at [http://localhost:8080/status] configured in `/src/server.ts`.
<% } %><% if (sentry) { %>
### Sentry

This project uses [@sentry/node](https://docs.sentry.io/platforms/node/guides/express/) to report errors and perform requests tracing.

Sentry is configured in `/src/config/sentry.ts` and defaults to:

- Enabled only in `production` mode (`NODE_ENV` set to `production`)
- Reports only errors with a status `> 500`

To configure Sentry:

- First, create a free account from [sentry.io](https://sentry.io/signup/)
- Create a new project and retrieve its `DSN`
- Fill in the `SENTRY_DSN` and `SENTRY_ENVIRONMENT` environment variables in `.env` (captured automatically by `@sentry/node`)
<% } %><% if (socketIo) { %>
### Socket IO

This project uses [Socket.IO](https://socket.io/docs/v2/) for real-time events which is configured in `/src/loaders/socket-io.ts` and injected in the application as the `socket` service.
<% } %><% if (nodemailer) { %>
### Nodemailer

To send emails, this project uses [Nodemailer](https://github.com/nodemailer/nodemailer).

The SMTP transport is configured in `/src/loaders/mailer.ts` and injected in the application as the `mailer` service.

To configure the SMTP connection options, change the `SMTP_` environment variables in `.env`.
<% } %><% if (openapi) { %>
### API documentation

The API documentation is written based on the [OpenAPI](https://swagger.io/specification/) specification and located in the `/public/doc` folder.

The interface is generated by [ReDoc](https://github.com/Rebilly/ReDoc) and is available at `http://localhost:{PORT}/doc` when the server is running.
<% } %><% if (admin) { %>
### Admin panel

The admin panel is generated with [AdminBro](https://adminbro.com/docs) and configured in `/src/config/admin-bro.ts`.

All admin-related files should reside in `/src/admin`.
<% } %>
## Style Guide

### Filenames

All filenames should use `kebab-case`.

### Formatting

Formatting rules are defined in `.editorconfig`<% if (prettier) { %> and `.prettierrc`<% } %>.

General formatting rules are:

- Indentation of **2 spaces**
- Max line length of **100 characters**
- **Single quotes** instead of double quotes

The rules defined in `.editorconfig` ensure that the coding style guide will stay consistent between different editors (see [EditorConfig](https://editorconfig.org/) for more info).<% if (prettier) { %>
The rules defined in `.prettierrc` provide more advanced formatting options (see [Linting](#linting) section below).<% } %>

### Linting

Check for linting errors with:

```sh
yarn lint
```
<% if (eslint || prettier) { %>
Automatically fix linting errors with:

```sh
yarn lint:fix
```
<% } %>
More info:

- [tsc](https://www.typescriptlang.org/docs/handbook/compiler-options.html) for Typescript compiling errors (configuration file: [`tsconfig.json`](tsconfig.json))<% if (eslint) { %>
- [ESlint](https://eslint.org/) for TypeScript/JavaScript linting errors (configuration file: [`.eslintrc.json`](.eslintrc.json))<% } %><% if (prettier) { %>
- [Prettier](https://prettier.io/) for formatting errors (configuration file: [`.prettierrc`](.prettierrc))<% } %>
<% if (hook) { %>
### Pre-commit hook

In addition, a git pre-commit hook is configured to run before each commit to ensure that linting and formatting are ok.

The hook was created with `husky` and is configured in [`.huskyrc.json`](.huskyrc.json). It runs the `lint-staged` package which itself is configured in `package.json`.

More info:

- [Git hooks](https://git-scm.com/book/uz/v2/Customizing-Git-Git-Hooks)
- [husky](https://github.com/typicode/husky)
- [lint-staged](https://github.com/okonet/lint-staged)
<% } %><% if (openapi) { %>
## Version update

When updating the project's version number, do not forget to update:

- The `version` field in `package.json`
- The `info > version` field in `/public/doc/openapi.yml`
<% } %><% if (winston) { %>
## Logs

When running, the application outputs some logs. Two modules are used for this:

- [winston](https://github.com/winstonjs/winston): handles all application logs and writes the output to configured transports (file, console, etc)
- [morgan](https://github.com/expressjs/morgan): logs all incoming HTTP requests
<% if (sentry) { %>
In production mode (`NODE_ENV` set to `production`), all `error` logs are also sent to `Sentry`.
<% } %>
Please refer to `/src/config/logger.ts` to see winston configuration.
<% } %>